# File: .github/workflows/ai-apps-cicd.yml
name: AI Apps CI/CD Pipeline with Task Management

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      app_name:
        description: 'Specific app to deploy'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.detect.outputs.matrix }}
      has_changes: ${{ steps.detect.outputs.has_changes }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 2

    - name: Detect changed applications
      id: detect
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -n "${{ inputs.app_name }}" ]; then
          echo "matrix=[\"${{ inputs.app_name }}\"]" >> $GITHUB_OUTPUT
          echo "has_changes=true" >> $GITHUB_OUTPUT
        else
          CHANGED_DIRS=$(git diff --name-only HEAD~1 HEAD | grep -E '^[^/]+/' | cut -d'/' -f1 | sort -u)
          if [ -z "$CHANGED_DIRS" ]; then
            echo "matrix=[]" >> $GITHUB_OUTPUT
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            MATRIX_JSON=$(echo "$CHANGED_DIRS" | jq -R -s -c 'split("\n")[:-1]')
            echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changed directories: $CHANGED_DIRS"
          fi
        fi

  quality-gate:
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
      fail-fast: false

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Check application structure
      run: |
        cd ${{ matrix.app }}
        if [ ! -f "requirements.txt" ]; then
          echo "âŒ No requirements.txt found in ${{ matrix.app }}"
          exit 1
        fi
        echo "âœ… Application structure valid"

    - name: Install application dependencies
      run: |
        cd ${{ matrix.app }}
        pip install --upgrade pip
        pip install -r requirements.txt

        # Install testing dependencies
        pip install pytest pytest-cov pytest-asyncio safety bandit black ruff mypy || echo "Some test tools failed to install"

    - name: Run dependency security scan
      run: |
        cd ${{ matrix.app }}
        python -m safety check -r requirements.txt --json || echo "Security scan completed with warnings"

    - name: Run code quality checks
      run: |
        cd ${{ matrix.app }}

        # Format check
        python -m black --check . --exclude venv || echo "Black formatting issues found"

        # Lint check
        python -m ruff check . || echo "Ruff linting issues found"

        # Type checking (if type annotations exist)
        if grep -r "from typing import\|: str\|: int\|: bool" . --include="*.py" > /dev/null; then
          python -m mypy . --ignore-missing-imports || echo "Type checking issues found"
        fi

    - name: Run comprehensive application tests
      run: |
        cd ${{ matrix.app }}

        # Create test script dynamically
        cat > test_runner.py << 'EOF'
        import subprocess
        import sys
        import os
        from pathlib import Path

        def run_tests():
            test_dirs = ["tests", "test", "testing"]
            test_dir = None

            for test_dirname in test_dirs:
                if Path(test_dirname).exists():
                    test_dir = test_dirname
                    break

            if test_dir:
                print(f"Running tests in {test_dir}")
                result = subprocess.run([sys.executable, "-m", "pytest", test_dir, "-v"],
                                      capture_output=True, text=True)
                print(result.stdout)
                if result.stderr:
                    print("STDERR:", result.stderr)
                return result.returncode == 0
            else:
                print("No test directory found, creating basic import test")
                # Test basic imports
                try:
                    for py_file in Path(".").glob("*.py"):
                        if py_file.name not in ["setup.py", "test_runner.py"]:
                            spec = subprocess.run([sys.executable, "-c", f"import {py_file.stem}"],
                                                capture_output=True)
                            if spec.returncode != 0:
                                print(f"Failed to import {py_file.stem}")
                                return False
                    print("Basic import tests passed")
                    return True
                except Exception as e:
                    print(f"Import test failed: {e}")
                    return False

        if __name__ == "__main__":
            if run_tests():
                print("âœ… All tests passed")
                sys.exit(0)
            else:
                print("âŒ Tests failed")
                sys.exit(1)
        EOF

        python test_runner.py

    - name: Build Docker image
      run: |
        cd ${{ matrix.app }}

        # Create Dockerfile if it doesn't exist
        if [ ! -f "Dockerfile" ]; then
          cat > Dockerfile << EOF
        FROM python:3.11-slim

        WORKDIR /app

        # Install system dependencies
        RUN apt-get update && apt-get install -y \\
            build-essential \\
            && rm -rf /var/lib/apt/lists/*

        # Copy requirements and install Python dependencies
        COPY requirements.txt .
        RUN pip install --no-cache-dir -r requirements.txt

        # Copy application code
        COPY . .

        # Add health check
        COPY ../docker_health_check.py /app/health_check.py
        HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \\
          CMD python health_check.py

        # Set environment variables
        ENV PYTHONPATH=/app
        ENV APP_PORT=8000

        # Expose port
        EXPOSE 8000

        # Run application
        CMD ["python", "app.py"]
        EOF
        fi

        # Build image
        docker build -t ai-app-${{ matrix.app }}:${{ github.sha }} .

    - name: Test Docker container
      run: |
        # Start container in background
        docker run -d --name test-${{ matrix.app }} -p 8080:8000 ai-app-${{ matrix.app }}:${{ github.sha }}

        # Wait for startup
        sleep 30

        # Test health endpoint
        curl -f http://localhost:8080/health || echo "Health check not available"

        # Check container logs
        docker logs test-${{ matrix.app }}

        # Cleanup
        docker stop test-${{ matrix.app }}
        docker rm test-${{ matrix.app }}

  staging-deploy:
    needs: [detect-changes, quality-gate]
    if: github.ref == 'refs/heads/develop' && needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    environment: staging

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Deploy to staging
      run: |
        echo "ğŸš€ Deploying ${{ matrix.app }} to staging environment"

        # Simulate deployment (replace with actual deployment logic)
        echo "Deployment ID: staging-${{ matrix.app }}-${{ github.run_number }}"
        echo "Environment: staging"
        echo "Version: ${{ github.sha }}"

    - name: Run staging health checks
      run: |
        echo "ğŸ¥ Running staging health checks for ${{ matrix.app }}"

        # Simulate health checks
        sleep 10
        echo "âœ… Health checks passed"

    - name: Create mandatory follow-up tasks
      run: |
        echo "ğŸ“‹ Creating follow-up tasks for ${{ matrix.app }}"

        # Install task management requirements
        pip install requests python-dotenv

        # Create task creation script
        cat > create_tasks.py << 'EOF'
        import os
        import json
        import requests
        from datetime import datetime, timedelta

        def create_github_issue(title, body, labels):
            """Create GitHub issue for follow-up task"""
            url = f"https://api.github.com/repos/${{ github.repository }}/issues"
            headers = {
                "Authorization": f"token ${{ secrets.GITHUB_TOKEN }}",
                "Accept": "application/vnd.github.v3+json"
            }

            data = {
                "title": title,
                "body": body,
                "labels": labels
            }

            response = requests.post(url, json=data, headers=headers)
            if response.status_code == 201:
                return response.json()
            else:
                print(f"Failed to create issue: {response.text}")
                return None

        def send_slack_notification(message):
            """Send Slack notification"""
            webhook_url = "${{ secrets.SLACK_WEBHOOK }}"
            if not webhook_url:
                print("No Slack webhook configured")
                return

            payload = {"text": message}
            requests.post(webhook_url, json=payload)

        # Create follow-up tasks
        app_name = "${{ matrix.app }}"
        deployment_id = f"staging-{app_name}-${{ github.run_number }}"

        tasks = [
            {
                "title": f"Performance Monitoring Setup - {app_name}",
                "labels": ["follow-up", "performance", "staging"],
                "priority": "high",
                "hours": 2
            },
            {
                "title": f"Security Validation - {app_name}",
                "labels": ["follow-up", "security", "staging"],
                "priority": "critical",
                "hours": 4
            },
            {
                "title": f"Documentation Update - {app_name}",
                "labels": ["follow-up", "documentation", "staging"],
                "priority": "medium",
                "hours": 1
            }
        ]

        created_count = 0
        for task in tasks:
            due_date = (datetime.now() + timedelta(hours=task["hours"] * 8)).strftime("%Y-%m-%d")

            body = f"""
## ğŸ”„ Mandatory Follow-up Task

**Application**: {app_name}
**Deployment ID**: {deployment_id}
**Priority**: {task["priority"]}
**Estimated Hours**: {task["hours"]}
**Due Date**: {due_date}

### Task Description
This is a mandatory follow-up task created automatically after deployment to staging.

### Acceptance Criteria
- [ ] Task completed according to specification
- [ ] Documentation updated if required
- [ ] Next follow-up tasks created as needed
- [ ] Stakeholders notified of completion

### Next Steps
Upon completion of this task, create appropriate follow-up tasks according to the Continuous Task Management methodology.

---
*Auto-generated by CI/CD pipeline - Run #{os.environ.get('GITHUB_RUN_NUMBER', 'unknown')}*
"""

            issue = create_github_issue(task["title"], body, task["labels"])
            if issue:
                created_count += 1
                print(f"âœ… Created issue #{issue['number']}: {task['title']}")

        # Send Slack summary
        slack_message = f"""
ğŸš€ **Staging Deployment Complete**
ğŸ“± App: {app_name}
ğŸ”¢ Deployment: {deployment_id}
ğŸ“‹ Follow-up tasks created: {created_count}
ğŸ”— Repository: ${{ github.repository }}
"""
        send_slack_notification(slack_message)

        print(f"ğŸ“Š Summary: Created {created_count} follow-up tasks for {app_name}")
        EOF

        python create_tasks.py

  production-deploy:
    needs: [detect-changes, quality-gate]
    if: github.ref == 'refs/heads/main' && needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        app: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    environment: production

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Production deployment
      run: |
        echo "ğŸš€ Deploying ${{ matrix.app }} to production environment"
        echo "âš ï¸ Production deployment requires manual approval"
        echo "Deployment ID: prod-${{ matrix.app }}-${{ github.run_number }}"

    - name: Create production monitoring tasks
      run: |
        echo "ğŸ“Š Creating production monitoring and optimization tasks"
        # Additional production-specific tasks would be created here
